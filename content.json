{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/07/10/hello-world/"},{"title":"记录一次flutter app的逆向","text":"前言本文参考链接如下，参考了这篇文章中关于Flutter的基础内容，补充了关于Blutter使用的诸多细节 Android-Flutter逆向 | LLeaves Blog (lleavesg.top) 关于FlutterFlutter是谷歌使用Dart语言开发的高性能、跨端UI框架，可以通过一套代码，支持iOS、Android、Windows/MAC/Linux等多个平台，且能达到原生性能。 Flutter也可以与平台原生代码进行混合开发。 在开发中，Flutter应用会在一个 VM（程序虚拟机）中运行，从而可以在保留状态且无需重新编译的情况下，热重载相关的更新。对于发行版 (Release) ，Flutter 应用程序会直接编译为机器代码，即AOT（Ahead Of Time）。 Flutter体系结构Flutter体系结构是分层设计的，类似于Android的体系结构。 最上层是Framework层，即Flutter框架层，开发者可以通过 Flutter框架层 与 Flutter 交互，该框架提供了以 Dart 语言编写的现代响应式框架。Flutter框架相对较小，因为一些开发者可能会使用到的更高层级的功能已经被拆分到不同的软件包中，使用 Dart和 Flutter的核心库实现， Flutter引擎是一个用于高质量跨平台应用的可移植运行时，由C/C++编写。它实现了Flutter的核心库，包括动画和图形、文件和网络I/O、辅助功能支持、插件架构，以及用于开发、编译和运行Flutter应用程序的Dart运行时和工具链。引擎将底层C++代码包装成 Dart代码，通过dart:ui暴露给 Flutter框架层。 Flutter可以通过一套代码在多个平台使用依靠着嵌入层，嵌入层采用了适合当前平台的语言编写，例如 Android使用的是 Java和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。嵌入层提供一个程序入口，程序由此可以与底层操作系统进行协调。 .aweptlrswlky{zoom:50%;} Flutter编译模式以下部分内容引自：Flutter’s Compilation Patterns. People who built App with Flutter must… Flutter使用Dart作为应用程序开发编程语言，因此Flutter的编译模式与Dart的编译模式相关。下面这张表总结了Dart的编译模式。 .btqfvjscrtpf{zoom:50%;} Script:：最常见的 JIT 模式。就像 Node.js 一样，可以通过Dart VM命令行工具直接执行Dart源代码。 Script Snapshot： JIT模式。与Script模式不同，Script Snapshot会将源代码打包成代码的Token形式，这可以节省了在编译时词法分析器所花费的时间。 Application Snapshot： JIT模式。Dart的Application Snapshot有点像运行时的转储。它包含了从源代码解析的类和函数，所以运行时可以更快地进行加载和执行。但是这种快照与架构相关，在IA_32上生成的快照无法在X64平台上运行。 AOT：AOT模式。在这种模式下，Dart源代码会被翻译成汇编文件，然后汇编文件由汇编器为不同架构编译成二进制代码。 对于Flutter，其在上述编译模式的基础上进行了调整 Script和Script Snapshot：与Dart的模式一样，但Flutter从未使用过。 Kernel Snapshot：对应用代码进行中间字节码(Dart kernel格式)快照。通过避免Dart代码重新编译来实现移动端的快速启动，类似于Java字节码与JVM，核心快照是不依赖于体系架构的。 Core JIT：Dart编译代码的一种二进制格式。程序数据和指令打包成特定的二进制格式，供 Dart运行时加载。实际上该模式 是一种 AOT 模式。 AOT Assembly：即Dart的AOT模式，完全AOT预编译的本地代码。 在开发阶段，开发Android App时，为了实现热重载技术加速UI的开发，Flutter在这个阶段使用Kernel Snapshot 模式，即核心快照模式。在编译生成的app-deug.apk 中的资源目录下存在isolate_snapshot_data vm_snapshot_data 以及kernel_blob.bin ，前两个文件分别用于加速isolate启动，加速dart_vm启动，最后一个文件为业务代码的字节码。在lib目录中还存在libflutter.so，即flutter动态链接库，与实际业务代码无关。 .jblymqabnxhw{zoom:50%;} 在发布阶段，在生产模式下应用程序需要更快地执行。因此，Flutter 在编译应用程序代码时选择了 AOT 模式。但是，由于平台特性不同，编译模式也有很大不同。我们可以将这些总结为一个表格。 .hfmcqncfqrcv{zoom:50%;} 在Android上，Core JIT 和 AOT Assembly 两种编译模式都支持。默认使用 AOT Assembly 模式，将会生成 libapp.so 放入apk包中的lib目录下，由dart代码编译而来，除此之外还有 libflutter.so ，也就是flutter动态链接库，与业务代码无关。 Flutter逆向快照使用 readelf -s 命令读取保存快照信息的 libapp.so 将会输出下面的内容 12345678Symbol table '.dynsym' contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000380000 19680 OBJECT GLOBAL DEFAULT 7 _kDartVmSnapshot[...] 2: 0000000000384ce0 0x5e1a60 OBJECT GLOBAL DEFAULT 7 _kDartIsolateSna[...] 3: 00000000000001b0 12688 OBJECT GLOBAL DEFAULT 2 _kDartVmSnapshotData 4: 0000000000003340 0x378dd0 OBJECT GLOBAL DEFAULT 2 _kDartIsolateSna[...] 5: 0000000000000190 32 OBJECT GLOBAL DEFAULT 1 _kDartSnapshotBuildId _kDartVmSnapshotData： 代表 isolate 之间共享的 Dart 堆 (heap) 的初始状态。有助于更快地启动 Dart isolate，但不包含任何 isolate 专属的信息。 _kDartVmSnapshotInstructions：包含 VM 中所有 Dart isolate 之间共享的通用例程的 AOT 指令。这种快照的体积通常非常小，并且大多会包含程序桩 (stub)。 _kDartIsolateSnapshotData：代表 Dart 堆的初始状态，并包含 isolate 专属的信息。 _kDartIsolateSnapshotInstructions：包含由 Dart isolate 执行的 AOT 代码。 其中 _kDartIsolateSnapshotInstructions 是最为重要的，因为包含了所有要执行的AOT代码，即业务相关的代码。 Dart VM 中所有的代码都运行在一些 isolate 内， isolate 可以看作是一个隔离的Dart执行环境,有自己的全局状态和通常自己的执行线程（mutator线程）。 isolate 被组织成 isolate group ，同一个组内的 isolate 共享同一个垃圾回收堆，用于存储该 isolate组 分配的对象。 在Flutter中，不会使用多个 isolate ，除了始终存在的 VM isolate 之外，只使用一个 isolate。 .fjxdvjtfnvma{zoom: 50%;} Isolate中维护了堆栈变量，函数调用栈帧，用于GC、JIT等辅助任务的子线程等， 而这里的堆栈变量就是要被序列化到磁盘上的东西，即 IsolateSnapshot 。此外像dart预置的全局对象，比如null,true,false等等等是由VMIsolate管理的，这些东西需序列化后即 VmSnapshot 。最初快照不包括机器代码，但是后来在开发AOT编译器时添加了此功能。开发 AOT 编译器和带代码的快照的动机是允许在由于平台级别限制而无法进行 JIT 的平台上使用 VM。带代码的快照的工作方式与普通快照几乎相同，但略有不同：它们包含一个代码部分，与快照的其余部分不同，它不需要反序列化。此代码段的铺设方式允许它在映射到内存后直接成为堆的一部分。dart源码中 runtime/vm/app_snapshot.cc 处理快照的序列化和反序列化 .rybbnhfconvw{zoom:50%;} 一般逆向方法一般情况下要想获取更多关于业务代码相关的信息，暂时只有两种方法： 静态解析 libapp.so，即写一个解析器，将libapp.so中的快照数据按照其既定格式进行解析，获取业务代码的类的各种信息，包括类的名称、其中方法的偏移等数据，从而辅助逆向工作。 关于Flutter快照的具体刨析只需要看下面引用的两篇文章，因为这不是本文的重点，在这里不再详细展开： Reverse engineering Flutter apps (Part 1) (tst.sh) Reverse engineering Flutter apps (Part 2) (tst.sh) 编译修改过的 libflutter.so 并且重新打包到APK中，在启动APP的过程中，由修改过的引擎动态链接库将快照数据获取并且保存。本文主要采用这种方法。 上面的两种方法，分别对应着静态和动态，但是有着同样的缺点，高度依赖于引擎版本，不同版本的Dart引擎其快照格式不同，所以静态的方法就需要频繁跟着版本更新迭代，成本极高，而动态也需要重新编译对应版本的链接库。同时如果APP作者抹除版本信息和hash信息，则无从下手，而且重打包APK极易被检测到。 对于第一种方法相关项目有： rscloura/Doldrums: A Flutter/Dart reverse engineering tool (github.com) mildsunrise/darter: :detective: Dart / Flutter VM snapshot analyzer (github.com) Blutter工具，挺好用，根据不同编码的引擎编译不同版本的工具静态dump出源码信息，无需运行时dump即可实现https://github.com/worawit/blutter 对于第二种方法相关项目有： Impact-I/reFlutter: Flutter Reverse Engineering Framework (github.com) 使用Blutter实现Flutter APP的逆向本文使用Blutter来实现静态dump，该工具的使用方法可以参考https://github.com/worawit/blutter Blutter环境setup Environment SetupThis application uses C++20 Formatting library. It requires very recent C++ compiler such as g++&gt;=13, Clang&gt;=16. I recommend using Linux OS (only tested on Deiban sid/trixie) because it is easy to setup. 可以在readme中看到要求 g++ &gt;= 13 Clang &gt;= 16 我使用的是Ubuntu 22.04，apt中最高的g++版本也只到12，因此只有通过编译源码手动安装g++ 13 了。 首先使用wget下载对应13版本的源码 1wget http://ftp.gnu.org/gnu/gcc/gcc-13.1.0/gcc-13.1.0.tar.gz 然后解压 1tar -zxvf gcc-13.1.0.tar.gz 解压完成后进入源码根目录，然后使用指令来下载依赖 1./contrib/download_prerequisites 但是这个过程中可能会出现网络问题，可以使用以下指令来临时给shell配置科学上网 1export ALL_PROXY=&quot;http://ip:port&quot; 安装完成之后就可以创建构建目录，开始配置编译选项 12mkdir build &amp;&amp; cd build../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib --prefix=/usr/local/bin 注意，--prefix=/usr/local/bin 用于配置编译之后的安装位置，如果想以后直接使用g++13的话也可以不配置这一选项，这样的话编译之后就会安装到 /usr/bin ，如果有打快照或者做备份的能力，建议不要这个选项，会方便很多 安装完成之后，根据readme中给出的指令安装依赖（Debian） 12apt install python3-pyelftools python3-requests git cmake ninja-build \\ build-essential pkg-config libicu-dev libcapstone-dev 环境setup之后，从github拉取blutter的代码 1git clone https://github.com/worawit/blutter.git 然后使用指令启动执行即可 1python3 blutter.py path/to/app/lib/arm64-v8a out_dir 在这个过程中可能出现python的包依赖缺少的问题，缺什么装什么就可以了 PS:如果是缺少elftools，需要安装的包叫pyelftools 如果是报错如 12blutter/src/pch.h:12:10: fatal error: format: 没有那个文件或目录12 | #include &lt;format&gt; 这很可能是因为虽然make install之后使用 gcc --version 和 g++ --version 都能查看到新版本的输出，但是系统中 cc --version 和 c++ --version 这两个在make构建中常用的指令仍然指向旧的编译器版本，可以使用我给出的指令来测试一下是否如此，如果是这样的话，使用以下两条指令来解决这个问题（在Ubuntu中是如此的） 12update-alternatives --install /usr/bin/gcc gcc /path/to/your/gcc 130update-alternatives --install /usr/bin/g++ g++ /path/to/your/g++ 130 Blutter的执行blutter的使用难点个人感觉都在前面的环境配置部分，这可真是太计算机了，配环境是所有工作中最折磨的一部分 下面就是blutter的调用方法，如果再没有别的环境问题，应该是以下指令就可以直接跑通的 1python3 blutter.py path/to/app/lib/arm64-v8a out_dir 得到以下的文件，其中arm64-v8a和armeabi-v7a是app本身的lib目录，blutter生成的文件是剩下的那些文件 1234567891011ll总计 2828drwxrwxr-x 6 ubuntu ubuntu 4096 7月 12 21:26 ./drwxr-xr-x 11 ubuntu ubuntu 4096 7月 11 12:06 ../drwxrwxr-x 2 ubuntu ubuntu 4096 7月 11 12:06 arm64-v8a/drwxrwxr-x 2 ubuntu ubuntu 4096 7月 11 12:06 armeabi-v7a/drwxrwxr-x 66 ubuntu ubuntu 4096 7月 12 21:26 asm/-rw-rw-r-- 1 ubuntu ubuntu 293411 7月 12 21:26 blutter_frida.jsdrwxrwxr-x 2 ubuntu ubuntu 4096 7月 12 21:26 ida_script/-rw-rw-r-- 1 ubuntu ubuntu 337052 7月 12 21:26 objs.txt-rw-rw-r-- 1 ubuntu ubuntu 2236369 7月 12 21:26 pp.txt IDA打开libapp.so文件在Flutter应用程序中，libapp.so 是一个重要的组件，它是应用程序的原生代码部分，主要包含以下几个方面的内容： Flutter Engine的绑定：libapp.so 包含了与Flutter引擎交互的原生代码。Flutter引擎负责绘制UI、处理事件、执行Dart代码等，libapp.so 中的代码桥接了Flutter框架和原生平台（如Android或iOS）之间的通信。 Flutter Framework的原生部分：尽管Flutter的主要编程语言是Dart，但框架中也有部分原生代码，这些代码可能用于性能敏感的部分或平台特有的功能，这部分代码会被编译进libapp.so。 应用程序的原生依赖：如果你的应用程序使用了任何原生插件（例如，使用Camera插件访问摄像头），这些插件的原生实现也会被包含在libapp.so中。 Flutter Dart代码的JNI绑定：虽然Dart代码本身不会被编译成libapp.so的一部分，但Dart运行时需要与原生环境交互，这通常通过Java Native Interface (JNI)实现。libapp.so 包含了这些JNI绑定，使得Dart代码可以调用原生方法。 Tinkering和Hot Reload支持：libapp.so 还可能包含支持Tinkering（热修复）和Hot Reload的代码，使得开发者可以在不完全重启应用的情况下更新和调试Dart代码。 简而言之，Flutter逆向的主要分析目标就是libapp.so这个文件，而这也是blutter的作用所在，它能够帮助我们使用IDA来对libapp.so进行逆向分析 在blutter产生的文件中，主要在IDA反编译libapp.so文件过程中发挥作用的就是以下两个文件，它位于ida_script文件夹中 首先，使用IDA打开arm64-v8a目录下的libapp.so文件，可以看到什么符号都没有，这个时候就需要用到上面的两个文件了 .kwgvqmcwqdez{zoom:50%;} 在IDA中点击 File-&gt;Script File-&gt;选择addNames.py 然后就可以执行脚本来添加符号，等待执行完毕就可以得到符号表了，但是这个符号表是来自Dart SDK的符号表，并不代表得到了这个app开发过程中开发者命名的符号","link":"/2024/07/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1flutter-app%E7%9A%84%E9%80%86%E5%90%91/"},{"title":"Java反序列化","text":"为什么会产生序列化的安全问题1. 引子序列化与反序列化当中有两个 “特别特别特别特别特别” 重要的方法 ———— writeObject 和 readObject。 这两个方法可以经过开发者重写，一般序列化的重写都是由于下面这种场景诞生的。 举个例子，MyList 这个类定义了一个 arr 数组属性，初始化的数组长度为 100。在实际序列化时如果让 arr 属性参与序列化的话，那么长度为 100 的数组都会被序列化下来，但是我在数组中可能只存放 30 个数组而已，这明显是不可理的，所以这里就要自定义序列化过程啦，具体的做法是重写以下两个 private 方法： 12private void writeObject(java.io.ObjectOutputStream s)throws java.io.IOExceptionprivate void readObject(java.io.ObjectInputStream s)throws java.io.IOException, ClassNotFoundException 只要服务端反序列化数据，客户端传递类的 readObject 中代码会自动执行，基于攻击者在服务器上运行代码的能力。 所以从根本上来说，Java 反序列化的漏洞的与 readObject 有关。 Java 安全可以从反序列化说起，而反序列化可以从反射说起反射机制相关操作一般位于java.lang.reflect包中。而java反射机制组成需要重点注意以下的类： 1234java.lang.Class：类对象;java.lang.reflect.Constructor：类的构造器对象;java.lang.reflect.Field：类的属性对象;java.lang.reflect.Method：类的方法对象; 1234获取类的方法：forName实例化类对象的方法：newInstance获取函数的方法：getMethod执行函数的方法：invoke 获取类的Class对象的三种方法123456// 1 obj为目标类的实例Class class = obj.getClass()// 2 使用类的.class方法Class class = Obj.class// 3 使用Class.forName(String className) 动态的获取Class class = Class.forName(&quot;package.Obj&quot;) 获取类的成员变量 Field获取成员变量Field位于 java.lang.reflect.Field 包中 1234Field[] getFields() ：获取所有 public 修饰的成员变量Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符Field getField(String name) 获取指定名称的 public 修饰的成员变量Field getDeclaredField(String name) 获取指定的成员变量 获取成员方法 Method要注意，第一个参数是传参，第二个参数是确定重载的是哪个函数。 1234567891011//第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型//返回该类所声明的public方法Method getMethod(String name, 类&lt;?&gt;... parameterTypes) //返回该类所声明的方法Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) //获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法Method[] getMethods() Method[] getDeclaredMethods() // 获取该类中的所有方法 获取构造函数Constructor1234567Constructor&lt;?&gt;[] getConstructors() ：只返回public构造函数Constructor&lt;?&gt;[] getDeclaredConstructors() ：返回所有构造函数Constructor&lt;&gt; getConstructor(类&lt;?&gt;... parameterTypes) : 匹配和参数配型相符的public构造函数Constructor&lt;&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) ： 匹配和参数配型相符的构造函数 反射创建对象反射创建对象，即反射之后实例化对象，使用的是newInstance 12Class class = Class.forName(&quot;package.Obj&quot;);Object obj = class.newInstance(); invoke方法invoke 方法位于 java.lang.reflect.Method 类中，用于执行某个的对象的目标方法。一般会和 getMethod 方法配合进行调用invoke方法的声明如下 1public Object invoke(Object obj, Object... args) 第一个参数为类的实例，第二个参数为相应函数中的参数obj：从中调用底层方法的对象，必须是实例化对象args： 用于方法的调用，是一个 object 的数组，参数有可能是多个但需要注意的是，invoke 方法第一个参数并不是固定的：如果调用这个方法是普通方法，第一个参数就是类对象；如果调用这个方法是静态方法，第一个参数就是类； 反射的例子通过上面讲到的内容，可以写个完整的例子 123456789101112package mytest;import java.lang.reflect.Method;public class ReflectionTest{ public static void main(String[] args) throws Exception { Class class = Class.forName(&quot;mytest.Obj&quot;); Object object = class.newInstance(); Method method = class.getMethod(&quot;reflect&quot;); method.invoke(object); }} 反射进阶关于java.lang.Runtime 为什么要用这个 Runtime 类？ 我们知道 Java 当中很多的 CVE 漏洞，都与反序列化有关，反序列化也与 RCE 有关，而 Runtime 这个类正是用来命令执行的。 最主要的原因，Runtime 类中有 exec 方法，可以用来命令执行。 设置setAccessible(true)访问权限在一般情况下，我们使用反射机制不能对类的私有 private 字段进行操作，绕过私有权限的访问。但一些特殊场景存在例外的时候，比如我们进行序列化操作的时候，需要去访问这些受限的私有字段，这时我们可以通过调用 AccessibleObject 上的 setAccessible() 方法来允许访问。 -这种方法与 getConstructor 配合使用和 getMethod 类似，getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载，所以必须用参数列表类型才能唯一确定一个构造函数。以弹计算器为例。 12345678910111213package mytest; import java.lang.reflect.Constructor; // 进阶使用反射 public class ReflectionCalc { public static void main(String[] args) throws Exception{ Class class = Class.forName(&quot;java.lang.Runtime&quot;); Constructor m = class.getDeclaredConstructor(); m.setAccessible(true); //本来Runtime的构造器是私有的 class.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(),&quot;C:\\\\WINDOWS\\\\System32\\\\calc.exe&quot;); } } forName的两个重载的区别对于Class.forName()方法，有两个重载 12forName(String className)forName(String name, boolean initialize, ClassLoader loader) 第一个参数表示类名第二个参数表示是否初始化第三个参数表示类加载器，即告诉Java虚拟机如何加载这个类，Java默认的ClassLoader就是根据类名来加载类， 这个类名是类完整路路径，如 java.lang.Runtime 因此，forName(className)等价于forName(className, true, currentLoader) 代码块的执行顺序对于以下示例代码 12345678910111213141516171819202122package mytest; // 各种代码块执行顺序 public class FunctionSort { public static void main(String[] args) throws Exception{ Test test = new Test(); } static class Test{ { System.out.println(&quot;1&quot;); } static { System.out.println(&quot;2&quot;); } Test(){ System.out.println(&quot;3&quot;); } } } 执行结果如下 123213 运行⼀下就知道了，首先调用的是 static {} ，其次是 {} ，最后是构造函数。 其中， static {} 就是在“类初始化”的时候调用的，⽽ {} 中的代码会放在构造函数的 super() 后⾯，但在当前构造函数内容的前面 所以说， forName 中的 initialize=true 其实就是告诉 Java 虚拟机是否执行“类初始化”。 那么，假设我们有如下函数，其中函数的参数name可控： 123public void ref(String name) throws Exception { Class.forName(name);} 那么我们就可以构造一个恶意类，并将恶意代码放置在static {}中，从而使得类初始化的时候就执行我们的恶意代码逻辑 1234567891011121314import java.lang.Runtime;import java.lang.Process;public class TouchFile { static { try { Runtime rt = Runtime.getRuntime(); String[] commands = {&quot;touch&quot;, &quot;/tmp/success&quot;}; Process pc = rt.exec(commands); pc.waitFor(); } catch (Exception e) { } }} Java命令执行的三种方式反序列化当中我们需要入口类，需要执行链，还需要一个命令执行的方法。 使用Runtime进行命令执行下面是示例程序 123456789101112131415161718package mytest; import java.io.ByteArrayOutputStream; import java.io.InputStream; // 使用 Runtime 类进行命令执行 public class RuntimeExec { public static void main(String[] args) throws Exception{ InputStream inputStream = Runtime.getRuntime().exec(&quot;whoami&quot;).getInputStream(); byte[] cache = new byte[1024]; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int readLen = 0; while ((readLen = inputStream.read(cache)) != -1) { byteArrayOutputStream.write(cache, 0, readLen); } System.out.println(byteArrayOutputStream); } } 大致思路：先调用 getRuntime() 返回一个 Runtime 对象，然后调用 Runtime 对象的 exec 的方法。 使用ProcessBuilder下面是示例程序 12345678910111213141516package mytest; import java.io.ByteArrayOutputStream; import java.io.InputStream; // 使用 ProcessBuilder 进行命令执行操作 public class ProcessBuilderExec { public static void main(String[] args) throws Exception{ InputStream inputStream = new ProcessBuilder(&quot;ipconfig&quot;).start().getInputStream(); byte[] cache = new byte[1024]; int readLen = 0; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); while ((readLen = inputStream.read(cache)) != -1){ byteArrayOutputStream.write(cache, 0, readLen); } System.out.println(byteArrayOutputStream); } } 本质上并没有什么区别 使用ProcessImplProcessImpl 是更为底层的实现，Runtime 和 ProcessBuilder 执行命令实际上也是调用了 ProcessImpl 这个类，对于 ProcessImpl 类我们不能直接调用，但是可以通过反射来间接调用 ProcessImpl 来达到执行命令的目的。 代码示例如下 1234567891011121314151617181920212223242526package mytest; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.lang.reflect.Method; import java.util.Map; // 使用 ProcessImpl 进行命令执行 public class ProcessImplExec { public static void main(String[] args) throws Exception{ String[] cmds = new String[]{&quot;whoami&quot;}; Class clazz = Class.forName(&quot;java.lang.ProcessImpl&quot;); Method method = clazz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class); method.setAccessible(true); Process e = (Process) method.invoke(null, cmds, null, &quot;.&quot;, null, true); InputStream inputStream = e.getInputStream(); byte[] cache = new byte[1024]; int readLen = 0; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); while ((readLen = inputStream.read(cache)) != -1){ byteArrayOutputStream.write(cache, 0, readLen); } System.out.println(byteArrayOutputStream); } } 关键字修饰的变量如何用反射访问staticstatic 单独出现的话，getDeclaredField 就可以实现访问例如代码 1234567891011121314151617181920public class StaticPerson { private static StringBuilder name = new StringBuilder(&quot;string&quot;); public void printInfo() { System.out.println(name); } }public class StaticReflect { public static void main(String[] args) throws Exception{ Class c = Class.forName(&quot;mytest.ReflectFixFinal.pojo.StaticPerson&quot;); Object m = c.newInstance(); Method nameMethod = c.getDeclaredMethod(&quot;printInfo&quot;); nameMethod.invoke(m); Field nameField = c.getDeclaredField(&quot;name&quot;); nameField.setAccessible(true); nameField.set(m, new StringBuilder(&quot;newString&quot;)); nameMethod.invoke(m); } } finalfinal 字段能否修改，取决于字段是直接赋值还是间接赋值（编译时赋值和运行时赋值的区别）。直接赋值是指在创建字段时就对字段进行赋值，并且值为 JAVA 的 8 种基础数据类型或者 String 类型，而且值不能是经过逻辑判断产生的，其他情况均为间接赋值。 间接赋值的情况下按顺序调用getDeclaredField()和setAccessible(true)即可 static + final使用 static final 修饰符的 name 属性，并且是间接赋值，直接通过反射修改是不可以的。这里我们需要通过反射, 把 nameField 的 final 修饰符去掉，再赋值。示例代码如下 12345678910111213141516171819202122232425public class StaticFinalPerson { static final StringBuilder name = new StringBuilder(&quot;string&quot;); public void printInfo() { System.out.println(name); } }public class StaticFinalReflect { public static void main(String[] args) throws Exception{ Class c = Class.forName(&quot;mytest.ReflectFixFinal.pojo.StaticFinalPerson&quot;); Object m = c.newInstance(); Method printMethod = c.getDeclaredMethod(&quot;printInfo&quot;); printMethod.invoke(m); Field nameField = c.getDeclaredField(&quot;name&quot;); nameField.setAccessible(true); Field nameModifyField = nameField.getClass().getDeclaredField(&quot;modifiers&quot;); nameModifyField.setAccessible(true); nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL); nameField.set(m,new StringBuilder(&quot;newSTtring&quot;)); nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL); printMethod.invoke(m); } } 其中关键的就是 123456Field nameField = c.getDeclaredField(&quot;name&quot;); nameField.setAccessible(true); Field nameModifyField = nameField.getClass().getDeclaredField(&quot;modifiers&quot;); nameModifyField.setAccessible(true); nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL); JDK动态代理JDK的动态代理需要了解两个类 核心 : InvocationHandler 调用处理程序类和 Proxy 代理类 InvocationHandler：调用处理程序 1public interface InvocationHandler InvocationHandler是由代理实例的调用处理程序实现的接口 每个代理实例都有一个关联的调用处理程序。 1Object invoke(Object proxy, 方法 method, Object[] args)； proxy – 调用该方法的代理实例 method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。当在代理实例上调用方法的时候，方法调用将被编码并分派到其调用处理程序的invoke()方法","link":"/2025/02/18/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"逆向","slug":"逆向","link":"/tags/%E9%80%86%E5%90%91/"},{"name":"Blutter","slug":"Blutter","link":"/tags/Blutter/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"Java反序列化","slug":"Java反序列化","link":"/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"flutter","slug":"flutter","link":"/categories/flutter/"},{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"网络安全","slug":"网络安全","link":"/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"pages":[]}