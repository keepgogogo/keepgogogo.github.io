{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/07/10/hello-world/"},{"title":"记录一次flutter app的逆向","text":"前言本文参考链接如下： Android-Flutter逆向 | LLeaves Blog (lleavesg.top) 关于FlutterFlutter是谷歌使用Dart语言开发的高性能、跨端UI框架，可以通过一套代码，支持iOS、Android、Windows/MAC/Linux等多个平台，且能达到原生性能。 Flutter也可以与平台原生代码进行混合开发。 在开发中，Flutter应用会在一个 VM（程序虚拟机）中运行，从而可以在保留状态且无需重新编译的情况下，热重载相关的更新。对于发行版 (Release) ，Flutter 应用程序会直接编译为机器代码，即AOT（Ahead Of Time）。 Flutter体系结构Flutter体系结构是分层设计的，类似于Android的体系结构。 最上层是Framework层，即Flutter框架层，开发者可以通过 Flutter框架层 与 Flutter 交互，该框架提供了以 Dart 语言编写的现代响应式框架。Flutter框架相对较小，因为一些开发者可能会使用到的更高层级的功能已经被拆分到不同的软件包中，使用 Dart和 Flutter的核心库实现， Flutter引擎是一个用于高质量跨平台应用的可移植运行时，由C/C++编写。它实现了Flutter的核心库，包括动画和图形、文件和网络I/O、辅助功能支持、插件架构，以及用于开发、编译和运行Flutter应用程序的Dart运行时和工具链。引擎将底层C++代码包装成 Dart代码，通过dart:ui暴露给 Flutter框架层。 Flutter可以通过一套代码在多个平台使用依靠着嵌入层，嵌入层采用了适合当前平台的语言编写，例如 Android使用的是 Java和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。嵌入层提供一个程序入口，程序由此可以与底层操作系统进行协调。 .vvdgxpoozirf{zoom:50%;} Flutter编译模式以下部分内容引自：Flutter’s Compilation Patterns. People who built App with Flutter must… Flutter使用Dart作为应用程序开发编程语言，因此Flutter的编译模式与Dart的编译模式相关。下面这张表总结了Dart的编译模式。 .wabtmltgqtwu{zoom:50%;} Script:：最常见的JIT模式。就像Node.js一样，可以通过Dart VM命令行工具直接执行Dart源代码。 Script Snapshot： JIT模式。与Script模式不同，Script Snapshot会将源代码打包成代码的Token形式，这可以节省了在编译时词法分析器所花费的时间。 Application Snapshot： JIT模式。Dart的Application Snapshot有点像运行时的转储。它包含了从源代码解析的类和函数，所以运行时可以更快地进行加载和执行。但是这种快照与架构相关，在IA_32上生成的快照无法在X64平台上运行。 AOT：AOT模式。在这种模式下，Dart源代码会被翻译成汇编文件，然后汇编文件由汇编器为不同架构编译成二进制代码。 对于Flutter，其在上述编译模式的基础上进行了调整 Script和Script Snapshot：与Dart的模式一样，但Flutter从未使用过。 Kernel Snapshot：对应用代码进行中间字节码(Dart kernel格式)快照。通过避免Dart代码重新编译来实现移动端的快速启动，类似于Java字节码与JVM，核心快照是不依赖于体系架构的。 Core JIT：Dart编译代码的一种二进制格式。程序数据和指令打包成特定的二进制格式，供 Dart运行时加载。实际上该模式 是一种 AOT 模式。 AOT Assembly：即Dart的AOT模式，完全AOT预编译的本地代码。 在开发阶段，开发Android App时，为了实现热重载技术加速UI的开发，Flutter在这个阶段使用Kernel Snapshot 模式，即核心快照模式。在编译生成的app-deug.apk 中的资源目录下存在isolate_snapshot_data vm_snapshot_data 以及kernel_blob.bin ，前两个文件分别用于加速isolate启动，加速dart_vm启动，最后一个文件为业务代码的字节码。在lib目录中还存在libflutter.so，即flutter动态链接库，与实际业务代码无关。 .tkdofbezvtyx{zoom:50%;} 在发布阶段，在生产模式下应用程序需要更快地执行。因此，Flutter 在编译应用程序代码时选择了 AOT 模式。但是，由于平台特性不同，编译模式也有很大不同。我们可以将这些总结为一个表格。 .ieydqcqymfsg{zoom:50%;} 在Android上，Core JIT和AOT Assembly 两种编译模式都支持。默认使用AOT Assembly 模式，将会生成libapp.so放入apk包中的lib目录下，由dart代码编译而来，除此之外还有libflutter.so，也就是flutter动态链接库，与业务代码无关。 Flutter逆向快照使用 readelf -s 命令读取保存快照信息的 libapp.so 将会输出下面的内容 12345678Symbol table '.dynsym' contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000380000 19680 OBJECT GLOBAL DEFAULT 7 _kDartVmSnapshot[...] 2: 0000000000384ce0 0x5e1a60 OBJECT GLOBAL DEFAULT 7 _kDartIsolateSna[...] 3: 00000000000001b0 12688 OBJECT GLOBAL DEFAULT 2 _kDartVmSnapshotData 4: 0000000000003340 0x378dd0 OBJECT GLOBAL DEFAULT 2 _kDartIsolateSna[...] 5: 0000000000000190 32 OBJECT GLOBAL DEFAULT 1 _kDartSnapshotBuildId _kDartVmSnapshotData： 代表 isolate 之间共享的 Dart 堆 (heap) 的初始状态。有助于更快地启动 Dart isolate，但不包含任何 isolate 专属的信息。 _kDartVmSnapshotInstructions：包含 VM 中所有 Dart isolate 之间共享的通用例程的 AOT 指令。这种快照的体积通常非常小，并且大多会包含程序桩 (stub)。 _kDartIsolateSnapshotData：代表 Dart 堆的初始状态，并包含 isolate 专属的信息。 _kDartIsolateSnapshotInstructions：包含由 Dart isolate 执行的 AOT 代码。 其中 _kDartIsolateSnapshotInstructions 是最为重要的，因为包含了所有要执行的AOT代码，即业务相关的代码。 Dart VM 中所有的代码都运行在一些 isolate 内， isolate 可以看作是一个隔离的Dart执行环境,有自己的全局状态和通常自己的执行线程（mutator线程）。 isolate 被组织成 isolate group ，同一个组内的 isolate 共享同一个垃圾回收堆，用于存储该 isolate组 分配的对象。 在Flutter中，不会使用多个 isolate ，除了始终存在的 VM isolate 之外，只使用一个 isolate。 .pdfyfrjitdej{zoom: 50%;} Isolate中维护了堆栈变量，函数调用栈帧，用于GC、JIT等辅助任务的子线程等， 而这里的堆栈变量就是要被序列化到磁盘上的东西，即 IsolateSnapshot 。此外像dart预置的全局对象，比如null,true,false等等等是由VMIsolate管理的，这些东西需序列化后即 VmSnapshot 。最初快照不包括机器代码，但是后来在开发AOT编译器时添加了此功能。开发 AOT 编译器和带代码的快照的动机是允许在由于平台级别限制而无法进行 JIT 的平台上使用 VM。带代码的快照的工作方式与普通快照几乎相同，但略有不同：它们包含一个代码部分，与快照的其余部分不同，它不需要反序列化。此代码段的铺设方式允许它在映射到内存后直接成为堆的一部分。dart源码中 runtime/vm/app_snapshot.cc 处理快照的序列化和反序列化 .fvsbygivudkn{zoom:50%;} 一般逆向方法","link":"/2024/07/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1flutter-app%E7%9A%84%E9%80%86%E5%90%91/"}],"tags":[{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"逆向","slug":"逆向","link":"/tags/%E9%80%86%E5%90%91/"}],"categories":[{"name":"flutter","slug":"flutter","link":"/categories/flutter/"},{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"}],"pages":[]}