{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/07/10/hello-world/"},{"title":"记录一次flutter app的逆向","text":"前言本文参考链接如下： Android-Flutter逆向 | LLeaves Blog (lleavesg.top) 关于FlutterFlutter是谷歌使用Dart语言开发的高性能、跨端UI框架，可以通过一套代码，支持iOS、Android、Windows/MAC/Linux等多个平台，且能达到原生性能。 Flutter也可以与平台原生代码进行混合开发。 在开发中，Flutter应用会在一个 VM（程序虚拟机）中运行，从而可以在保留状态且无需重新编译的情况下，热重载相关的更新。对于发行版 (Release) ，Flutter 应用程序会直接编译为机器代码，即AOT（Ahead Of Time）。 Flutter体系结构Flutter体系结构是分层设计的，类似于Android的体系结构。 最上层是Framework层，即Flutter框架层，开发者可以通过 Flutter框架层 与 Flutter 交互，该框架提供了以 Dart 语言编写的现代响应式框架。Flutter框架相对较小，因为一些开发者可能会使用到的更高层级的功能已经被拆分到不同的软件包中，使用 Dart和 Flutter的核心库实现， Flutter引擎是一个用于高质量跨平台应用的可移植运行时，由C/C++编写。它实现了Flutter的核心库，包括动画和图形、文件和网络I/O、辅助功能支持、插件架构，以及用于开发、编译和运行Flutter应用程序的Dart运行时和工具链。引擎将底层C++代码包装成 Dart代码，通过dart:ui暴露给 Flutter框架层。 Flutter可以通过一套代码在多个平台使用依靠着嵌入层，嵌入层采用了适合当前平台的语言编写，例如 Android使用的是 Java和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。嵌入层提供一个程序入口，程序由此可以与底层操作系统进行协调。 .sfbyoshemwyx{zoom:50%;} Flutter编译模式以下部分内容引自：Flutter’s Compilation Patterns. People who built App with Flutter must… Flutter使用Dart作为应用程序开发编程语言，因此Flutter的编译模式与Dart的编译模式相关。下面这张表总结了Dart的编译模式。 .pwxutvkueoeu{zoom:50%;} Script:：最常见的 JIT 模式。就像 Node.js 一样，可以通过Dart VM命令行工具直接执行Dart源代码。 Script Snapshot： JIT模式。与Script模式不同，Script Snapshot会将源代码打包成代码的Token形式，这可以节省了在编译时词法分析器所花费的时间。 Application Snapshot： JIT模式。Dart的Application Snapshot有点像运行时的转储。它包含了从源代码解析的类和函数，所以运行时可以更快地进行加载和执行。但是这种快照与架构相关，在IA_32上生成的快照无法在X64平台上运行。 AOT：AOT模式。在这种模式下，Dart源代码会被翻译成汇编文件，然后汇编文件由汇编器为不同架构编译成二进制代码。 对于Flutter，其在上述编译模式的基础上进行了调整 Script和Script Snapshot：与Dart的模式一样，但Flutter从未使用过。 Kernel Snapshot：对应用代码进行中间字节码(Dart kernel格式)快照。通过避免Dart代码重新编译来实现移动端的快速启动，类似于Java字节码与JVM，核心快照是不依赖于体系架构的。 Core JIT：Dart编译代码的一种二进制格式。程序数据和指令打包成特定的二进制格式，供 Dart运行时加载。实际上该模式 是一种 AOT 模式。 AOT Assembly：即Dart的AOT模式，完全AOT预编译的本地代码。 在开发阶段，开发Android App时，为了实现热重载技术加速UI的开发，Flutter在这个阶段使用Kernel Snapshot 模式，即核心快照模式。在编译生成的app-deug.apk 中的资源目录下存在isolate_snapshot_data vm_snapshot_data 以及kernel_blob.bin ，前两个文件分别用于加速isolate启动，加速dart_vm启动，最后一个文件为业务代码的字节码。在lib目录中还存在libflutter.so，即flutter动态链接库，与实际业务代码无关。 .kbvvklkxffmc{zoom:50%;} 在发布阶段，在生产模式下应用程序需要更快地执行。因此，Flutter 在编译应用程序代码时选择了 AOT 模式。但是，由于平台特性不同，编译模式也有很大不同。我们可以将这些总结为一个表格。 .rnlblebxilbe{zoom:50%;} 在Android上，Core JIT 和 AOT Assembly 两种编译模式都支持。默认使用 AOT Assembly 模式，将会生成 libapp.so 放入apk包中的lib目录下，由dart代码编译而来，除此之外还有 libflutter.so ，也就是flutter动态链接库，与业务代码无关。 Flutter逆向快照使用 readelf -s 命令读取保存快照信息的 libapp.so 将会输出下面的内容 12345678Symbol table '.dynsym' contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000380000 19680 OBJECT GLOBAL DEFAULT 7 _kDartVmSnapshot[...] 2: 0000000000384ce0 0x5e1a60 OBJECT GLOBAL DEFAULT 7 _kDartIsolateSna[...] 3: 00000000000001b0 12688 OBJECT GLOBAL DEFAULT 2 _kDartVmSnapshotData 4: 0000000000003340 0x378dd0 OBJECT GLOBAL DEFAULT 2 _kDartIsolateSna[...] 5: 0000000000000190 32 OBJECT GLOBAL DEFAULT 1 _kDartSnapshotBuildId _kDartVmSnapshotData： 代表 isolate 之间共享的 Dart 堆 (heap) 的初始状态。有助于更快地启动 Dart isolate，但不包含任何 isolate 专属的信息。 _kDartVmSnapshotInstructions：包含 VM 中所有 Dart isolate 之间共享的通用例程的 AOT 指令。这种快照的体积通常非常小，并且大多会包含程序桩 (stub)。 _kDartIsolateSnapshotData：代表 Dart 堆的初始状态，并包含 isolate 专属的信息。 _kDartIsolateSnapshotInstructions：包含由 Dart isolate 执行的 AOT 代码。 其中 _kDartIsolateSnapshotInstructions 是最为重要的，因为包含了所有要执行的AOT代码，即业务相关的代码。 Dart VM 中所有的代码都运行在一些 isolate 内， isolate 可以看作是一个隔离的Dart执行环境,有自己的全局状态和通常自己的执行线程（mutator线程）。 isolate 被组织成 isolate group ，同一个组内的 isolate 共享同一个垃圾回收堆，用于存储该 isolate组 分配的对象。 在Flutter中，不会使用多个 isolate ，除了始终存在的 VM isolate 之外，只使用一个 isolate。 .vkihodrhseae{zoom: 50%;} Isolate中维护了堆栈变量，函数调用栈帧，用于GC、JIT等辅助任务的子线程等， 而这里的堆栈变量就是要被序列化到磁盘上的东西，即 IsolateSnapshot 。此外像dart预置的全局对象，比如null,true,false等等等是由VMIsolate管理的，这些东西需序列化后即 VmSnapshot 。最初快照不包括机器代码，但是后来在开发AOT编译器时添加了此功能。开发 AOT 编译器和带代码的快照的动机是允许在由于平台级别限制而无法进行 JIT 的平台上使用 VM。带代码的快照的工作方式与普通快照几乎相同，但略有不同：它们包含一个代码部分，与快照的其余部分不同，它不需要反序列化。此代码段的铺设方式允许它在映射到内存后直接成为堆的一部分。dart源码中 runtime/vm/app_snapshot.cc 处理快照的序列化和反序列化 .ncoppdlwdotr{zoom:50%;} 一般逆向方法一般情况下要想获取更多关于业务代码相关的信息，暂时只有两种方法： 静态解析 libapp.so，即写一个解析器，将libapp.so中的快照数据按照其既定格式进行解析，获取业务代码的类的各种信息，包括类的名称、其中方法的偏移等数据，从而辅助逆向工作。 关于Flutter快照的具体刨析只需要看下面引用的两篇文章，因为这不是本文的重点，在这里不再详细展开： Reverse engineering Flutter apps (Part 1) (tst.sh) Reverse engineering Flutter apps (Part 2) (tst.sh) 编译修改过的 libflutter.so 并且重新打包到APK中，在启动APP的过程中，由修改过的引擎动态链接库将快照数据获取并且保存。本文主要采用这种方法。 上面的两种方法，分别对应着静态和动态，但是有着同样的缺点，高度依赖于引擎版本，不同版本的Dart引擎其快照格式不同，所以静态的方法就需要频繁跟着版本更新迭代，成本极高，而动态也需要重新编译对应版本的链接库。同时如果APP作者抹除版本信息和hash信息，则无从下手，而且重打包APK极易被检测到。 对于第一种方法相关项目有： rscloura/Doldrums: A Flutter/Dart reverse engineering tool (github.com) mildsunrise/darter: :detective: Dart / Flutter VM snapshot analyzer (github.com) Blutter工具，挺好用，根据不同编码的引擎编译不同版本的工具静态dump出源码信息，无需运行时dump即可实现https://github.com/worawit/blutter 对于第二种方法相关项目有： Impact-I/reFlutter: Flutter Reverse Engineering Framework (github.com) Blutter工具使用本文使用Blutter来实现静态dump，该工具的使用方法可以参考https://github.com/worawit/blutter 环境setup Environment SetupThis application uses C++20 Formatting library. It requires very recent C++ compiler such as g++&gt;=13, Clang&gt;=16. I recommend using Linux OS (only tested on Deiban sid/trixie) because it is easy to setup. 可以在readme中看到要求 g++ &gt;= 13 Clang &gt;= 16 我使用的是Ubuntu 22.04，apt中最高的g++版本也只到12，因此只有通过编译源码手动安装g++ 13 了。 首先使用wget下载对应13版本的源码 1wget http://ftp.gnu.org/gnu/gcc/gcc-13.1.0/gcc-13.1.0.tar.gz 然后解压 1tar -zxvf gcc-13.1.0.tar.gz 解压完成后进入源码根目录，然后使用指令来下载依赖 1./contrib/download_prerequisites 但是这个过程中可能会出现网络问题，可以使用以下指令来临时给shell配置科学上网 1export ALL_PROXY=&quot;http://ip:port&quot; 安装完成之后就可以创建构建目录，开始配置编译选项 12mkdir build &amp;&amp; cd build../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib --prefix=/usr/local/bin 注意，--prefix=/usr/local/bin 用于配置编译之后的安装位置，如果想以后直接使用g++13的话也可以不配置这一选项，这样的话编译之后就会安装到 /usr/bin ，如果有打快照或者做备份的能力，建议不要这个选项，会方便很多 安装完成之后，根据readme中给出的指令安装依赖（Debian） 12apt install python3-pyelftools python3-requests git cmake ninja-build \\ build-essential pkg-config libicu-dev libcapstone-dev 环境setup之后，从github拉取blutter的代码 1git clone https://github.com/worawit/blutter.git 然后使用指令启动执行即可 1python3 blutter.py path/to/app/lib/arm64-v8a out_dir 在这个过程中可能出现python的包依赖缺少的问题，缺什么装什么就可以了 PS:如果是缺少elftools，需要安装的包叫pyelftools 如果是报错如 12blutter/src/pch.h:12:10: fatal error: format: 没有那个文件或目录12 | #include &lt;format&gt; 这很可能是因为虽然make install之后使用 gcc --version 和 g++ --version 都能查看到新版本的输出，但是系统中 cc --version 和 c++ --version 这两个在make构建中常用的指令仍然指向旧的编译器版本，可以使用我给出的指令来测试一下是否如此，如果是这样的话，使用以下两条指令来解决这个问题（在Ubuntu中是如此的） 12update-alternatives --install /usr/bin/gcc gcc /path/to/your/gcc 130update-alternatives --install /usr/bin/g++ g++ /path/to/your/g++ 130 Blutter的执行blutter的使用难点个人感觉都在前面的环境配置部分，这可真是太计算机了，配环境是所有工作中最折磨的一部分 下面就是blutter的调用方法，如果再没有别的环境问题，应该是以下指令就可以直接跑通的 1python3 blutter.py path/to/app/lib/arm64-v8a out_dir","link":"/2024/07/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1flutter-app%E7%9A%84%E9%80%86%E5%90%91/"}],"tags":[{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"逆向","slug":"逆向","link":"/tags/%E9%80%86%E5%90%91/"}],"categories":[{"name":"flutter","slug":"flutter","link":"/categories/flutter/"},{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"}],"pages":[]}